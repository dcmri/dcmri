
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dcmri.pk &#8212; dcmri 0.6.17 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=cd8af66b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=0d21fabb"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-64ZSJ8Z1MX"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-64ZSJ8Z1MX');
            </script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-64ZSJ8Z1MX');
            </script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/dcmri/pk';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/tristan-logo.jpg" class="logo__image only-light" alt="dcmri 0.6.17 documentation - Home"/>
    <img src="../../_static/tristan-logo.jpg" class="logo__image only-dark pst-js-only" alt="dcmri 0.6.17 documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contribute/index.html">
    Contribute
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../releases/index.html">
    Releases
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../about/index.html">
    About
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dcmri/dcmri" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contribute/index.html">
    Contribute
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../releases/index.html">
    Releases
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dcmri/dcmri" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">dcmri.pk</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for dcmri.pk</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">trapezoid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">lambertw</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dcmri.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>

<span class="c1"># Wrappers</span>


<div class="viewcode-block" id="flux">
<a class="viewcode-back" href="../../api/dcmri.flux.html#dcmri.flux">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux</span><span class="p">(</span><span class="n">J</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;comp&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flux out of an arbitrary pharmacokinetic system.</span>

<span class="sd">    This is a wrapper function offering a standard interface to calculate the </span>
<span class="sd">    flux out of a specific system, with the system architecture specified in </span>
<span class="sd">    the dictionary. It offers a convenient way to build more complex models </span>
<span class="sd">    with variable configurations, such as `dcmri.flux_aorta`.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the trap.</span>
<span class="sd">        params (tuple): model parameters.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J. If </span>
<span class="sd">          t=None, the time points are assumed to be uniformly spaced with </span>
<span class="sd">          spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly </span>
<span class="sd">          spaced time points. This parameter is ignored if t is explicity </span>
<span class="sd">          provided. Defaults to 1.0.</span>
<span class="sd">        model (str, optional): Model to use, options are &#39;trap&#39;, &#39;pass&#39;, </span>
<span class="sd">          &#39;comp&#39;, &#39;plug&#39;, &#39;chain&#39;, &#39;step&#39;, &#39;free&#39;, &#39;ncomp&#39;, &#39;nscomp&#39;, </span>
<span class="sd">          &#39;pfcomp&#39;, &#39;mmcomp&#39;, &#39;2cxm&#39;. Defaults to &#39;comp&#39;.</span>
<span class="sd">        kwargs (dict): any optional parameters required by the model.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If a system is specified that is nto yet implemented.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Total outflux out of the system.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;trap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_trap</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;pass&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_pass</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;comp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;plug&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;chain&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_chain</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_step</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;free&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_free</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;ncomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_ncomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;nscomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_nscomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;pfcomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_pfcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;mmcomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_mmcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;2cxm&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_2cxm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Model &#39;</span> <span class="o">+</span> <span class="n">model</span> <span class="o">+</span> <span class="s1">&#39; is not currently implemented.&#39;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<div class="viewcode-block" id="conc">
<a class="viewcode-back" href="../../api/dcmri.conc.html#dcmri.conc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc</span><span class="p">(</span><span class="n">J</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;comp&#39;</span><span class="p">,</span> 
         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concentration in an arbitrary pharmacokinetic system.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the trap.</span>
<span class="sd">        params (tuple): model parameters.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J. </span>
<span class="sd">          If t=None, the time points are assumed to be uniformly spaced with </span>
<span class="sd">          spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly </span>
<span class="sd">          spaced time points. This parameter is ignored if t is explicity </span>
<span class="sd">          provided. Defaults to 1.0.</span>
<span class="sd">        model (str, optional): Model to use, options are &#39;trap&#39;, &#39;pass&#39;, </span>
<span class="sd">          &#39;comp&#39;, &#39;plug&#39;, &#39;chain&#39;, &#39;step&#39;, &#39;free&#39;, &#39;ncomp&#39;, &#39;nscomp&#39;, </span>
<span class="sd">          &#39;mmcomp&#39;, &#39;2cxm&#39;. Defaults to &#39;comp&#39;.</span>

<span class="sd">    This is a wrapper function offering a standard interface to calculate the concentration in a specific system.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If a system is specified that is not yet implemented.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Concentration in the system.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;trap&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_trap</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;pass&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_pass</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;comp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;plug&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;chain&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_chain</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_step</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;free&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_free</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;ncomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_ncomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;nscomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_nscomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;mmcomp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_mmcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;2cxm&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_2cxm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Model &#39;</span> <span class="o">+</span> <span class="n">model</span> <span class="o">+</span> <span class="s1">&#39; is not currently implemented.&#39;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<span class="c1"># 0 Parameters</span>

<span class="c1"># Trap</span>

<div class="viewcode-block" id="res_trap">
<a class="viewcode-back" href="../../api/dcmri.res_trap.html#dcmri.res_trap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_trap</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a trap.</span>

<span class="sd">    See section :ref:`define-trap` for more detail. </span>

<span class="sd">    Args:</span>
<span class="sd">        t (array_like): Time points where the residue function is calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: residue function as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_trap`, `conc_trap`, `flux_trap`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,1,2,3,4]</span>
<span class="sd">        &gt;&gt;&gt; dc.res_trap(t)</span>
<span class="sd">        array([1., 1., 1., 1., 1.])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span></div>



<div class="viewcode-block" id="prop_trap">
<a class="viewcode-back" href="../../api/dcmri.prop_trap.html#dcmri.prop_trap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_trap</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a trap.</span>

<span class="sd">    See section :ref:`define-trap` for more detail. </span>
<span class="sd">     </span>
<span class="sd">    Args:</span>
<span class="sd">        t (array_like): Time points where the propagator is calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_trap`, `conc_trap`, `flux_trap`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,1,2,3,4]</span>
<span class="sd">        &gt;&gt;&gt; dc.prop_trap(t)</span>
<span class="sd">        array([0., 0., 0., 0., 0.])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span></div>



<div class="viewcode-block" id="conc_trap">
<a class="viewcode-back" href="../../api/dcmri.conc_trap.html#dcmri.conc_trap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_trap</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator tissue concentration inside a trap.</span>

<span class="sd">    See section :ref:`define-trap` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the trap.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J. If </span>
<span class="sd">          t=None, the time points are assumed to be uniformly spaced with </span>
<span class="sd">          spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly </span>
<span class="sd">          spaced time points. This parameter is ignored if t is explicity </span>
<span class="sd">          provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_trap`, `prop_trap`, `flux_trap`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_trap(J, dt=2.0)</span>
<span class="sd">        array([ 0.,  3.,  8., 14., 19.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_trap">
<a class="viewcode-back" href="../../api/dcmri.flux_trap.html#dcmri.flux_trap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_trap</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a trap.</span>

<span class="sd">    See section :ref:`define-trap` for more detail. </span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the trap.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_trap`, `conc_trap`, `prop_trap`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_trap(J, dt=2.0)</span>
<span class="sd">        array([0., 0., 0., 0., 0.])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span></div>



<span class="c1"># 1 Parameter</span>

<span class="c1"># Pass (no dispersion)</span>

<div class="viewcode-block" id="res_pass">
<a class="viewcode-back" href="../../api/dcmri.res_pass.html#dcmri.res_pass">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_pass</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a pass.</span>

<span class="sd">    See section :ref:`define-pass` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): transit time of the pass.</span>
<span class="sd">        t (array_like): Time points where the residue function is calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: residue function of the pass as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_pass`, `conc_pass`, `flux_pass`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.res_pass(5,t)</span>
<span class="sd">        array([3.33333333, 0.        , 0.        , 0.        ])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">T</span><span class="o">*</span><span class="n">utils</span><span class="o">.</span><span class="n">ddelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="prop_pass">
<a class="viewcode-back" href="../../api/dcmri.prop_pass.html#dcmri.prop_pass">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_pass</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a pass.</span>

<span class="sd">    See section :ref:`define-pass` for more detail.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        t (array_like): Time points where the propagator is calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_pass`, `conc_pass`, `flux_pass`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.prop_pass(t)</span>
<span class="sd">        array([0.66666667, 0.        , 0.        , 0.        ])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">ddelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="conc_pass">
<a class="viewcode-back" href="../../api/dcmri.conc_pass.html#dcmri.conc_pass">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_pass</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a pass.</span>

<span class="sd">    See section :ref:`define-pass` for more detail.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the pass.</span>
<span class="sd">        T (float): transit time of the pass.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_pass`, `prop_pass`, `flux_pass`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_pass(J, 5)</span>
<span class="sd">        array([ 5, 10, 15, 15, 10])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">T</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_pass">
<a class="viewcode-back" href="../../api/dcmri.flux_pass.html#dcmri.flux_pass">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_pass</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a pass.</span>

<span class="sd">    See section :ref:`define-pass` for more detail.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the pass.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_pass`, `conc_pass`, `prop_pass`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_pass(J)</span>
<span class="sd">        array([1, 2, 3, 3, 2]) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span></div>



<span class="c1"># Compartment</span>

<div class="viewcode-block" id="res_comp">
<a class="viewcode-back" href="../../api/dcmri.res_comp.html#dcmri.res_comp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a compartment.</span>

<span class="sd">    See section :ref:`define-compartment` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the compartment. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        t (array_like): time points where the residue function is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: residue function of the compartment as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_comp`, `conc_comp`, `flux_comp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.res_comp(5,t)</span>
<span class="sd">        array([1.        , 0.54881164, 0.44932896, 0.30119421])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res_trap</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">T</span><span class="p">)</span></div>



<div class="viewcode-block" id="prop_comp">
<a class="viewcode-back" href="../../api/dcmri.prop_comp.html#dcmri.prop_comp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a compartment.</span>

<span class="sd">    See section :ref:`define-compartment` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the compartment. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        t (array_like): time points where the propagator is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_comp`, `conc_comp`, `flux_comp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.prop_comp(5,t)</span>
<span class="sd">        array([0.2       , 0.10976233, 0.08986579, 0.06023884])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prop_trap</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">ddelta</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">T</span></div>



<div class="viewcode-block" id="conc_comp">
<a class="viewcode-back" href="../../api/dcmri.conc_comp.html#dcmri.conc_comp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a compartment.</span>

<span class="sd">    See section :ref:`define-compartment` for more detail. </span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment.</span>
<span class="sd">        T (float): mean transit time of the compartment. Any non-negative </span>
<span class="sd">          value is allowed, including :math:`T=0` and :math:`T=\\infty`, in </span>
<span class="sd">          which case the compartment is a trap.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in </span>
<span class="sd">          the same units as T. If t=None, the time points are assumed to be </span>
<span class="sd">          uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced </span>
<span class="sd">          time points, in the same units as T. This parameter is ignored if t </span>
<span class="sd">          is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_comp`, `prop_comp`, `flux_comp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_comp(J, 5, t)</span>
<span class="sd">        array([ 0.        ,  5.        , 12.16166179, 14.85868746, 10.83091743])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_trap</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">T</span><span class="o">*</span><span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_comp">
<a class="viewcode-back" href="../../api/dcmri.flux_comp.html#dcmri.flux_comp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a compartment.</span>

<span class="sd">    See section :ref:`define-compartment` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment.</span>
<span class="sd">        T (float): mean transit time of the compartment. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_comp`, `conc_comp`, `prop_comp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_comp(J, 5, t)</span>
<span class="sd">        array([0.        , 1.        , 2.43233236, 2.97173749, 2.16618349]) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_trap</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span></div>



<span class="c1"># Plug flow</span>

<div class="viewcode-block" id="prop_plug">
<a class="viewcode-back" href="../../api/dcmri.prop_plug.html#dcmri.prop_plug">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a plug flow system.</span>

<span class="sd">    See section :ref:`define-plug-flow` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the system is a trap.</span>
<span class="sd">        t (array_like): time points where the propagator is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_plug`, `conc_plug`, `flux_plug`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.prop_plug(5,t)</span>
<span class="sd">        array([0.        , 0.        , 0.33333333, 0.5       ])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">ddelta</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="res_plug">
<a class="viewcode-back" href="../../api/dcmri.res_plug.html#dcmri.res_plug">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a plug flow system.</span>

<span class="sd">    See section :ref:`define-plug-flow` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is </span>
<span class="sd">          allowed, including :math:`T=0` and :math:`T=\\infty`, in which </span>
<span class="sd">          case the system is a trap.</span>
<span class="sd">        t (array_like): time points where the residue function is calculated, </span>
<span class="sd">          in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: residue function as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_plug`, `conc_plug`, `flux_plug`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.res_plug(5,t)</span>
<span class="sd">        array([1.00000000e+00, 1.00000000e+00, 8.33333333e-01, 1.11022302e-16])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">utils</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="conc_plug">
<a class="viewcode-back" href="../../api/dcmri.conc_plug.html#dcmri.conc_plug">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a plug flow system.</span>

<span class="sd">    See section :ref:`define-plug-flow` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): solver for the system, either &#39;conv&#39; for explicit convolution with a discrete impulse response (slow) or &#39;interp&#39; for interpolation (fast). Defaults to &#39;interp&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_plug`, `prop_plug`, `flux_plug`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_plug(J, 5, t)</span>
<span class="sd">        array([ 0.        ,  6.38888889, 18.61111111, 22.5       , 16.25      ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_trap</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">*</span><span class="n">J</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;conv&#39;</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">res_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;interp&#39;</span><span class="p">:</span>
        <span class="n">Jo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">Jo</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_plug">
<a class="viewcode-back" href="../../api/dcmri.flux_plug.html#dcmri.flux_plug">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a plug flow system.</span>

<span class="sd">    See section :ref:`define-plug-flow` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the system is a trap.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): solver for the system, either &#39;conv&#39; for explicit convolution with a discrete impulse response (slow) or &#39;interp&#39; for interpolation (fast). Defaults to &#39;interp&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_plug`, `conc_plug`, `prop_plug`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_plug(J, 5, t)</span>
<span class="sd">        array([0.        , 0.44444444, 23.0555556, 3.        , 2.22222222]) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_trap</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;conv&#39;</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">prop_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;interp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Solver &#39;</span> <span class="o">+</span> <span class="n">solver</span> <span class="o">+</span> <span class="s1">&#39; does not exist.&#39;</span><span class="p">)</span></div>



<span class="c1"># 2 Parameters</span>

<span class="c1"># Chain</span>

<div class="viewcode-block" id="prop_chain">
<a class="viewcode-back" href="../../api/dcmri.prop_chain.html#dcmri.prop_chain">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_chain</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a chain system.</span>

<span class="sd">    See section :ref:`define-chain` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the system is a trap.</span>
<span class="sd">        D (float): dispersion of the system. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like): time points where the propagator is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if one of the parameters is out of bounds.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_chain`, `conc_chain`, `flux_chain`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.prop_chain(5, 0.5, t)</span>
<span class="sd">        array([0.        , 0.14457322, 0.12921377, 0.08708924])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;T must be non-negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;D cannot be negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;D cannot be larger than 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prop_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prop_comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">D</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">nexpconv</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">T</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span></div>



<div class="viewcode-block" id="res_chain">
<a class="viewcode-back" href="../../api/dcmri.res_chain.html#dcmri.res_chain">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_chain</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a chain system.</span>

<span class="sd">    See section :ref:`define-chain` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the system is a trap.</span>
<span class="sd">        D (float): dispersion of the system. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like): time points where the residue function is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_chain`, `conc_chain`, `flux_chain`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.res_chain(5, 0.5, t)</span>
<span class="sd">        array([1.        , 0.78314017, 0.64624667, 0.42994366])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res_comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_chain</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">utils</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="conc_chain">
<a class="viewcode-back" href="../../api/dcmri.conc_chain.html#dcmri.conc_chain">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_chain</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a chain system.</span>

<span class="sd">    See section :ref:`define-chain` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        D (float): dispersion of the system. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_chain`, `prop_chain`, `flux_chain`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_chain(J, 5, 0.5, t)</span>
<span class="sd">        array([ 0.        ,  6.59776478, 20.98038139, 30.80370764, 33.53283379])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># TODO: THIS NEEDS DEBUGGING</span>
    <span class="c1"># if solver==&#39;diag&#39;:</span>
    <span class="c1">#     n0 = np.floor(1/D)</span>
    <span class="c1">#     Tc, Ec = _chain_ncomp(n0, T)</span>
    <span class="c1">#     Ji = np.zeros((n0,len(J)))</span>
    <span class="c1">#     Ji[0,:] = J</span>
    <span class="c1">#     C = conc_ncomp(Ji, Tc, Ec, t=t, dt=dt).sum(axis=0)</span>
    <span class="c1">#     if n0==1/D:</span>
    <span class="c1">#         return C</span>
    <span class="c1">#     Tc, Ec = _chain_ncomp(n0+1, T)</span>
    <span class="c1">#     C += conc_ncomp(Ji, Tc, Ec, t=t, dt=dt).sum(axis=0)</span>
    <span class="c1">#     return C/2</span>

    <span class="n">tr</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">res_chain</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_chain">
<a class="viewcode-back" href="../../api/dcmri.flux_chain.html#dcmri.flux_chain">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_chain</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a chain system.</span>

<span class="sd">    See section :ref:`define-chain` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        D (float): dispersion of the system. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_chain`, `prop_chain`, `conc_chain`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_chain(J, 5, 0.5, t)</span>
<span class="sd">        array([0.        , 0.36089409, 1.92047375, 2.63639739, 1.99640464])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># TODO: This needs debugging</span>
    <span class="c1"># if solver==&#39;diag&#39;:</span>
    <span class="c1">#     n0 = int(np.floor(1/D))</span>
    <span class="c1">#     Tc, Ec = _chain_ncomp(n0, T)</span>
    <span class="c1">#     Ji = np.zeros((n0,len(J)))</span>
    <span class="c1">#     Ji[0,:] = J</span>
    <span class="c1">#     Jo = flux_ncomp(Ji, Tc, Ec, t=t, dt=dt)[n0-1,n0-1,:]</span>
    <span class="c1">#     if n0==1/D:</span>
    <span class="c1">#         return Jo</span>
    <span class="c1">#     Tc, Ec = _chain_ncomp(n0+1, T)</span>
    <span class="c1">#     Jo += flux_ncomp(Ji, Tc, Ec, t=t, dt=dt)[n0,n0,:]</span>
    <span class="c1">#     return Jo/2</span>

    <span class="n">th</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_chain</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">th</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span></div>


<span class="c1"># Helper function in diag solver for chain model</span>
<span class="c1"># def _chain_ncomp(n, T):</span>
<span class="c1">#     # Helper function</span>
<span class="c1">#     Tarr = np.full(n, T/n)</span>
<span class="c1">#     E = np.zeros((n,n))</span>
<span class="c1">#     for i in range(n-1):</span>
<span class="c1">#         E[i+1,i] = 1</span>
<span class="c1">#     E[n-1,n-1] = 1</span>
<span class="c1">#     return Tarr, E</span>


<span class="c1"># Step</span>

<div class="viewcode-block" id="prop_step">
<a class="viewcode-back" href="../../api/dcmri.prop_step.html#dcmri.prop_step">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_step</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a step system.</span>

<span class="sd">    See section :ref:`define-step` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the system is a trap.</span>
<span class="sd">        D (float): dispersion of the system, or half-width of the step given as a fraction of T. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like): time points where the propagator is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if one of the parameters is out of bounds.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_step`, `conc_step`, `flux_step`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.prop_step(5, 0.5, t)</span>
<span class="sd">        array([0.03508772, 0.21052632, 0.21052632, 0.21052632])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;T must be non-negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;D cannot be negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;D cannot be larger than 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prop_trap</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prop_plug</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">dstep</span><span class="p">(</span><span class="n">T</span><span class="o">-</span><span class="n">D</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="n">D</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="res_step">
<a class="viewcode-back" href="../../api/dcmri.res_step.html#dcmri.res_step">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_step</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a step system.</span>

<span class="sd">    See section :ref:`define-step` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the system is a trap.</span>
<span class="sd">        D (float): dispersion of the system, or half-width of the step given as a fraction of T. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like): time points where the residue function is calculated, in the same units as T.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_step`, `conc_step`, `flux_step`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,3,4,6]</span>
<span class="sd">        &gt;&gt;&gt; dc.res_step(5, 0.5, t)</span>
<span class="sd">        array([1.        , 0.63157895, 0.42105263, 0.        ])  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_step</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">utils</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="conc_step">
<a class="viewcode-back" href="../../api/dcmri.conc_step.html#dcmri.conc_step">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_step</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a step system.</span>

<span class="sd">    See section :ref:`define-step` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        D (float): dispersion of the system, or half-width of the step given as a fraction of T. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_step`, `prop_step`, `flux_step`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_step(J, 5, 0.5, t)</span>
<span class="sd">        array([ 0.        ,  6.44736842, 20.19736842, 28.20175439, 21.58625731])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">res_step</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_step">
<a class="viewcode-back" href="../../api/dcmri.flux_step.html#dcmri.flux_step">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_step</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a step system.</span>

<span class="sd">    See section :ref:`define-step` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        T (float): mean transit time of the system. Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        D (float): dispersion of the system, or half-width of the step given as a fraction of T. Values must be between 0 (no dispersion) and 1 (maximal dispersion).</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_step`, `prop_step`, `conc_step`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_step(J, 5, 0.5, t)</span>
<span class="sd">        array([0.        , 0.45614035, 1.9254386 , 2.91812865, 2.29239766])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_step</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_pfcomp">
<a class="viewcode-back" href="../../api/dcmri.flux_pfcomp.html#dcmri.flux_pfcomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_pfcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a serial arrangement of a plug flow </span>
<span class="sd">    system and a compartment.</span>

<span class="sd">    See section :ref:`define-pfcomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment (mmol/sec).</span>
<span class="sd">        T (float): mean transit time of the compartment (sec). Any non-negative value is allowed, including :math:`T=0` and :math:`T=\\infty`, in which case the compartment is a trap.</span>
<span class="sd">        D (float): Dispersion of the systemd defined as the ratio of the compartmental mean transit time versus the total mean transit time.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J (sec). If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points (sec). This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): solver for the system, either &#39;conv&#39; for explicit convolution with a discrete impulse response (slow) or &#39;interp&#39; for interpolation (fast). Defaults to &#39;interp&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarrayx: Outflux in mmol/sec</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">D</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dispersion must be in the range [0,1]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flux_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Tc</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="n">T</span>
    <span class="n">Tp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">T</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">flux_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Tc</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">flux_plug</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Tp</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">J</span></div>




<span class="c1"># N parameters</span>

<span class="c1"># Free</span>


<div class="viewcode-block" id="prop_free">
<a class="viewcode-back" href="../../api/dcmri.prop_free.html#dcmri.prop_free">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_free</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator or transit time distribution of a free system.</span>

<span class="sd">    See section :ref:`define-free` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        H (array_like): frequencies of the transit time histogram in each transit time bin. These do not have to be normalized - the function normalizes to unit area by default.</span>
<span class="sd">        t (array_like): time points where the propagator is calculated, in the same units as T.</span>
<span class="sd">        TT (array_like): boundaries of the transit time histogram bins. The number of elements in this array must be one more than the number of elements in H. If TT is not provided, the boundaries are equally distributed between TTmin and TTmax. Defaults to None.</span>
<span class="sd">        TTmin (float): Minimal transit time to be considered. If TT is provided, this argument is ignored. Defaults to 0.</span>
<span class="sd">        TTmax (float): Maximal transit time to be considered. If TT is provided, this argument is ignored. Defaults to the maximum of t.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: propagator as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if the array of transit times has the incorrect length.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_free`, `conc_free`, `flux_free`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,1,2,3]</span>

<span class="sd">        Assume the transit time histogram is provided by two equally sized bins covering the entire time interval, with frequencies 2 and 1, respectively:</span>

<span class="sd">        &gt;&gt;&gt; dc.prop_free([2,1], t)</span>
<span class="sd">        array([0.33333333, 0.41666667, 0.33333333, 0.16666667]) </span>

<span class="sd">        Assume the transit time has two equally sized bins, but between the values [0.5, 2.5]: </span>

<span class="sd">        &gt;&gt;&gt; dc.prop_free([2,1], t, TTmin=0.5, TTmax=2.5)</span>
<span class="sd">        array([0.19047619, 0.47619048, 0.38095238, 0.0952381 ])</span>

<span class="sd">        Assume the transit time histogram is provided by two bins in the same range, but with different sizes: one from 0.5 to 1 and the other from 1 to 2.5. The frequencies in the bins are the same as in the previous example:</span>

<span class="sd">        &gt;&gt;&gt; dc.prop_free([2,1], t, TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([0.33333333, 0.64814815, 0.14814815, 0.07407407]) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nTT</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">TT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">TTmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">TTmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">TT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">TTmin</span><span class="p">,</span> <span class="n">TTmax</span><span class="p">,</span> <span class="n">nTT</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nTT</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;The array of transit time boundaries needs to have length N+1, &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> with N the size of the transit time distribution H.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ddist</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">/</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="res_free">
<a class="viewcode-back" href="../../api/dcmri.res_free.html#dcmri.res_free">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_free</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of a free system.</span>

<span class="sd">    See section :ref:`define-free` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        H (array_like): frequencies of the transit time histogram in each transit time bin. These do not have to be normalized - the function normalizes to unit area by default.</span>
<span class="sd">        t (array_like): time points where the residue function is calculated, in the same units as T.</span>
<span class="sd">        TT (array_like): boundaries of the transit time histogram bins. The number of elements in this array must be one more than the number of elements in H. If TT is not provided, the boundaries are equally distributed between TTmin and TTmax. Defaults to None.</span>
<span class="sd">        TTmin (float): Minimal transit time to be considered. If TT is provided, this argument is ignored. Defaults to 0.</span>
<span class="sd">        TTmax (float): Maximal transit time to be considered. If TT is provided, this argument is ignored. Defaults to the maximum of t.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: residue function as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if the array of transit times has the incorrect length.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `prop_free`, `conc_free`, `flux_free`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,1,2,3]</span>

<span class="sd">        Assume the transit time histogram is provided by two equally sized bins covering the entire time interval, with frequencies 2 and 1, respectively:</span>

<span class="sd">        &gt;&gt;&gt; dc.res_free([2,1], t)</span>
<span class="sd">        array([1.   , 0.625, 0.25 , 0.   ]) </span>

<span class="sd">        Assume the transit time has two equally sized bins, but between the values [0.5, 2.5]: </span>

<span class="sd">        &gt;&gt;&gt; dc.res_free([2,1], t, TTmin=0.5, TTmax=2.5)</span>
<span class="sd">        array([1.00000000e+00, 6.66666667e-01, 2.38095238e-01, 2.22044605e-16])</span>

<span class="sd">        Assume the transit time histogram is provided by two bins in the same range, but with different sizes: one from 0.5 to 1 and the other from 1 to 2.5. The frequencies in the bins are the same as in the previous example:</span>

<span class="sd">        &gt;&gt;&gt; dc.res_free([2,1], t, TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([1.00000000e+00, 5.09259259e-01, 1.11111111e-01, 2.22044605e-16])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_free</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="n">TT</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="n">TTmin</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="n">TTmax</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">utils</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">r</span></div>



<div class="viewcode-block" id="conc_free">
<a class="viewcode-back" href="../../api/dcmri.conc_free.html#dcmri.conc_free">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_free</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;trap&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a free system.</span>

<span class="sd">    See section :ref:`define-free` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        H (array_like): frequencies of the transit time histogram in each transit time bin. These do not have to be normalized - the function normalizes to unit area by default.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        TT (array_like): boundaries of the transit time histogram bins. The number of elements in this array must be one more than the number of elements in H. If TT is not provided, the boundaries are equally distributed between TTmin and TTmax. Defaults to None.</span>
<span class="sd">        TTmin (float): Minimal transit time to be considered. If TT is provided, this argument is ignored. Defaults to 0.</span>
<span class="sd">        TTmax (float): Maximal transit time to be considered. If TT is provided, this argument is ignored. Defaults to the maximum of t.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_free`, `prop_free`, `flux_free`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>

<span class="sd">        Assume the transit time histogram is provided by two equally sized bins covering the entire time interval, with frequencies 2 and 1, respectively:</span>

<span class="sd">        &gt;&gt;&gt; dc.conc_free(J, [2,1], t)</span>
<span class="sd">        array([ 0.        ,  7.25308642, 29.41358025, 61.41975309, 77.56944444])</span>

<span class="sd">        Assume the transit time has two equally sized bins, but between the values [0.5, 2.5]: </span>

<span class="sd">        &gt;&gt;&gt; dc.conc_free(J, [2,1], t, TTmin=0.5, TTmax=2.5)</span>
<span class="sd">        array([ 0.        ,  4.75925926, 10.15740741, 11.5       ,  8.10185185])</span>

<span class="sd">        Assume the transit time histogram is provided by two bins in the same range, but with different sizes: one from 0.5 to 1 and the other from 1 to 2.5. The frequencies in the bins are the same as in the previous example:</span>

<span class="sd">        &gt;&gt;&gt; dc.conc_free(J, [2,1], t, TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([ 0.        ,  4.64814815,  9.58101852, 10.75      ,  7.5462963 ])</span>

<span class="sd">        If the time array is not provided, the function assumes uniform time resolution with time step = 1:</span>

<span class="sd">        &gt;&gt;&gt; dc.conc_free(J, [2,1], TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([0.        , 1.17777778, 2.45555556, 3.25277778, 3.075     ])</span>

<span class="sd">        If the time step is different from 1, it needs to be provided explicitly:</span>

<span class="sd">        &gt;&gt;&gt; dc.conc_free(J, [2,1], dt=2.0, TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([0.        , 2.05555556, 3.87037037, 4.76388889, 4.14351852])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">res_free</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="n">TT</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="n">TTmin</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="n">TTmax</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_free">
<a class="viewcode-back" href="../../api/dcmri.flux_free.html#dcmri.flux_free">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_free</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a free system.</span>

<span class="sd">    See section :ref:`define-free` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system.</span>
<span class="sd">        H (array_like): frequencies of the transit time histogram in each </span>
<span class="sd">          transit time bin. These do not have to be normalized - the function </span>
<span class="sd">          normalizes to unit area by default.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in </span>
<span class="sd">          the same units as T. If t=None, the time points are assumed to be </span>
<span class="sd">          uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly </span>
<span class="sd">          spaced time points, in the same units as T. This parameter is </span>
<span class="sd">          ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        TT (array_like): boundaries of the transit time histogram bins. The </span>
<span class="sd">          number of elements in this array must be one more than the number </span>
<span class="sd">          of elements in H. If TT is not provided, the boundaries are equally </span>
<span class="sd">          distributed between TTmin and TTmax. Defaults to None.</span>
<span class="sd">        TTmin (float): Minimal transit time to be considered. If TT is </span>
<span class="sd">          provided, this argument is ignored. Defaults to 0.</span>
<span class="sd">        TTmax (float): Maximal transit time to be considered. If TT is </span>
<span class="sd">          provided, this argument is ignored. Defaults to the maximum of t.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_free`, `prop_free`, `conc_free`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>

<span class="sd">        Assume the transit time histogram is provided by two equally sized bins covering the entire time interval, with frequencies 2 and 1, respectively:</span>

<span class="sd">        &gt;&gt;&gt; dc.flux_free(J, [2,1], t)</span>
<span class="sd">        array([0.        , 0.11111111, 0.48148148, 1.25102881, 2.60802469])</span>

<span class="sd">        Assume the transit time has two equally sized bins, but between the values [0.5, 2.5]: </span>

<span class="sd">        &gt;&gt;&gt; dc.flux_free(J, [2,1], t, TTmin=0.5, TTmax=2.5)</span>
<span class="sd">        array([0.        , 1.34074074, 2.69259259, 3.        , 2.1       ])</span>

<span class="sd">        Assume the transit time histogram is provided by two bins in the same range, but with different sizes: one from 0.5 to 1 and the other from 1 to 2.5. The frequencies in the bins are the same as in the previous example:</span>

<span class="sd">        &gt;&gt;&gt; dc.flux_free(J, [2,1], t, TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([0.        , 1.40185185, 2.71898148, 3.        , 2.09166667])</span>

<span class="sd">        If the time array is not provided, the function assumes uniform time resolution with time step = 1:</span>

<span class="sd">        &gt;&gt;&gt; dc.flux_free(J, [2,1], TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([0.        , 0.7       , 1.8       , 2.60555556, 2.69444444])</span>

<span class="sd">        If the time step is different from 1, it needs to be provided explicitly:</span>

<span class="sd">        &gt;&gt;&gt; dc.flux_free(J, [2,1], dt=2.0, TT=[0.5,1.0,2.5])</span>
<span class="sd">        array([0.        , 1.10185185, 2.24074074, 2.86574074, 2.59722222])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">prop_free</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">TT</span><span class="o">=</span><span class="n">TT</span><span class="p">,</span> <span class="n">TTmin</span><span class="o">=</span><span class="n">TTmin</span><span class="p">,</span> <span class="n">TTmax</span><span class="o">=</span><span class="n">TTmax</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span></div>



<span class="c1"># N compartments</span>

<span class="c1"># TODO: check that the sum of E&#39;s for a compartment = 1. Is it true that it can be something else? No sure..</span>
<span class="c1"># Maybe trapping and creation needs to be modelled with extra constants?</span>
<span class="c1"># The amounts trapped or created are not proportional to the amount inside.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_K_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="c1"># dC/dt = J - KC</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="c1"># Helper function</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Extraction fractions cannot be negative.&#39;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">size</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="c1"># Diagonal elements</span>
                <span class="c1"># sum of column i</span>
                <span class="n">Ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">E</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">Ei</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ei</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Off-diagonal elements</span>
                <span class="k">if</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">K</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_J_ncomp</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">_K_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="c1"># Flux to outside</span>
                <span class="n">Kii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Kii</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Flux to other compartments</span>
                <span class="n">J</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">J</span>

<span class="c1"># Helper function</span>


<span class="k">def</span><span class="w"> </span><span class="nf">conc_ncomp_prop</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dt_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">_K_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">nt</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
    <span class="n">Kmax</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Dk/nk &lt;= 1/Kmax</span>
        <span class="c1"># Dk*Kmax &lt;= nk</span>
        <span class="n">Dk</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">SJk</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">[:,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">J</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="n">Dk</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Dk</span><span class="o">*</span><span class="n">Kmax</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dt_prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Dk</span><span class="o">/</span><span class="n">dt_prop</span><span class="p">)),</span> <span class="n">nk</span><span class="p">])</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">Dk</span><span class="o">/</span><span class="n">nk</span>
        <span class="n">Jk</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
        <span class="n">Ck</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">Jk_next</span> <span class="o">=</span> <span class="n">Jk</span> <span class="o">+</span> <span class="n">dk</span><span class="o">*</span><span class="n">SJk</span>
            <span class="n">Ck_in</span> <span class="o">=</span> <span class="n">dk</span><span class="o">*</span><span class="p">(</span><span class="n">Jk</span><span class="o">+</span><span class="n">Jk_next</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">Ck</span> <span class="o">=</span> <span class="n">Ck</span> <span class="o">+</span> <span class="n">Ck_in</span> <span class="o">-</span> <span class="n">dk</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">Ck</span><span class="p">)</span>
            <span class="n">Jk</span> <span class="o">=</span> <span class="n">Jk_next</span>
        <span class="n">C</span><span class="p">[:,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ck</span>
    <span class="k">return</span> <span class="n">C</span>

<span class="c1"># Helper function</span>


<span class="k">def</span><span class="w"> </span><span class="nf">conc_ncomp_diag</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="c1"># Calculate system matrix, eigenvalues and eigenvectors</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">_K_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="c1"># From here, create generic function that solves n-comp system</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">Qi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="c1"># Initialize concentration-time array</span>
    <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">Ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Loop over the inlets</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="c1"># Loop over the eigenvalues</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
            <span class="c1"># Calculate elements of diagonal matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="o">/</span><span class="n">K</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
            <span class="c1"># Right-multiply with inverse eigenvector matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">Qi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="c1"># Left-multiply with eigenvector matrix</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Ei</span><span class="p">)</span>
    <span class="c1"># Absolute value because K can be complex</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>


<div class="viewcode-block" id="conc_ncomp">
<a class="viewcode-back" href="../../api/dcmri.conc_ncomp.html#dcmri.conc_ncomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_ncomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="n">dt_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concentration in a linear and stationary n-compartment system.</span>

<span class="sd">    See section :ref:`define-ncomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system, as a </span>
<span class="sd">          rectangular 2D array with dimensions *(n,k)*, where *n* is the </span>
<span class="sd">          number of compartments and *k* is the number of time points in *J*. </span>
<span class="sd">        T (array_like): n-element array with mean transit times of each </span>
<span class="sd">          compartment.</span>
<span class="sd">        E (array_like): dimensionless and square *n x n* matrix. An </span>
<span class="sd">          off-diagonal element *E[j,i]* is the extraction fraction from </span>
<span class="sd">          compartment *i* to compartment *j*. A diagonal element *E[i,i]* is </span>
<span class="sd">          the extraction fraction from compartment *i* to the outside. </span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux *J*, </span>
<span class="sd">          in the same units as *T*. If *t* is not provided, the time points </span>
<span class="sd">          are assumed to be uniformly spaced with spacing *dt*. Defaults to </span>
<span class="sd">          None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly </span>
<span class="sd">          spaced time points, in the same units as *T*. This parameter is </span>
<span class="sd">          ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): A string specifying the numerical method for </span>
<span class="sd">          solving the system. Two options are available: with </span>
<span class="sd">          `solver = &#39;diag&#39;` the system is solved by diagonalising the system </span>
<span class="sd">          matrix, with `solver = &#39;prop&#39;` the system is solved by forward </span>
<span class="sd">          propagation. The default is `&#39;diag&#39;`.</span>
<span class="sd">        dt_prop (float, optional): internal time resolution for the forward </span>
<span class="sd">          propagation when `solver = &#39;prop&#39;`. This must be in the same units </span>
<span class="sd">          as *T*. If *dt_prop* is not provided, it defaults to the sampling </span>
<span class="sd">          interval, or the smallest time step needed for stable results </span>
<span class="sd">          (whichever is smaller). This argument is ignored when </span>
<span class="sd">          `solver = &#39;diag&#39;`. Defaults to None. </span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration in each compartment, and at each time point, as a 2D array with dimensions *(n,k)*, where *n* is the number of compartments and *k* is the number of time points in *J*. </span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_ncomp`, `prop_ncomp`, `flux_ncomp`</span>

<span class="sd">    Note:</span>
<span class="sd">        The default solver `&#39;diag&#39;` should be most accurate and fastest, but currently does not allow for compartments that trap the tracer. It relies on matrix diagonalization which may be more problematic in very large systems, such as spatiotemporal models. The alternative solver `&#39;prop&#39;` is simple and robust and is a suitable alternative in such cases. It is slower and less accurate, though the accuracy can be improved at the cost of larger computation times by setting a smaller *dt_prop*. </span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>

<span class="sd">        Consider a measurement with 10 time points from 0 to 20s, and a 2-compartment system with a constant influx in each compartment. The influx in compartment 1 is twice a large than in compartment 0:</span>

<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 20, 10)</span>
<span class="sd">        &gt;&gt;&gt; J = np.zeros((2, t.size))</span>
<span class="sd">        &gt;&gt;&gt; J[0,:] = 1</span>
<span class="sd">        &gt;&gt;&gt; J[1,:] = 2</span>

<span class="sd">        The transit times are 6s for compartment 0 and 12s for compartment 1. </span>

<span class="sd">        &gt;&gt;&gt; T = [6,12]</span>

<span class="sd">        The extraction fraction from compartment 0 to compartment 1 is 0.3 and the extraction fraction from 1 to 0 is 0.8. These are the off-diagonal elements of *E*. No indicator is trapped or created inside the system so the extraction fractions for each compartment must add up to 1. The extraction fractions to the outside are therefore 0.7 and 0.2 for compartment 0 and 1, respectively. These are the diagonal elements of *E*:</span>

<span class="sd">        &gt;&gt;&gt; E = [</span>
<span class="sd">        ...  [0.7, 0.8],</span>
<span class="sd">        ...  [0.3, 0.2]]</span>

<span class="sd">        Calculate the concentrations in both compartments of the system:</span>

<span class="sd">        &gt;&gt;&gt; C = dc.conc_ncomp(J, T, E, t)</span>

<span class="sd">        The concentrations in compartment 0 are:</span>

<span class="sd">        &gt;&gt;&gt; C[0,:]</span>
<span class="sd">        array([ 0.        ,  2.13668993,  4.09491578,  5.87276879,  7.47633644,</span>
<span class="sd">        8.91605167, 10.20442515, 11.3546615 , 12.37983769, 13.29243667])</span>

<span class="sd">        The concentrations in compartment 1 are:</span>

<span class="sd">        &gt;&gt;&gt; C[1,:]</span>
<span class="sd">        array([ 0.        ,  4.170364  ,  7.84318653, 11.0842876 , 13.94862323, </span>
<span class="sd">        16.48272778, 18.72645063, 20.71421877, 22.47597717, 24.03790679])</span>

<span class="sd">        Solving by forward propagation produces a different result because of the relatively low time resolution:</span>

<span class="sd">        &gt;&gt;&gt; C = dc.conc_ncomp(J, T, E, t, solver=&#39;prop&#39;)</span>
<span class="sd">        &gt;&gt;&gt; C[1,:]</span>
<span class="sd">        array([ 0.        ,  4.44444444,  8.3127572 , 11.69333943, 14.65551209,</span>
<span class="sd">        17.25550803, 19.54012974, 21.54905722, 23.31636527, 24.87156916])</span>

<span class="sd">        But the difference can be made arbitrarily small by choosing a smaller *dt_prop* (at the cost of some computation time). In this case the results become very close with `dt_prop = 0.01`:</span>

<span class="sd">        &gt;&gt;&gt; C = dc.conc_ncomp(J, T, E, t, solver=&#39;prop&#39;, dt_prop=0.01)</span>
<span class="sd">        &gt;&gt;&gt; C[1,:]</span>
<span class="sd">        array([ 0.        ,  4.17147736,  7.84511918, 11.08681805, 13.95158088,</span>
<span class="sd">        16.48597905, 18.72988986, 20.71776196, 22.47955758, 24.04147164])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;prop&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conc_ncomp_prop</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt_prop</span><span class="o">=</span><span class="n">dt_prop</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;diag&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_conc_2comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conc_ncomp_diag</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_ncomp">
<a class="viewcode-back" href="../../api/dcmri.flux_ncomp.html#dcmri.flux_ncomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_ncomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="n">dt_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Outfluxes out of a linear and stationary n-compartment system.</span>

<span class="sd">    See section :ref:`define-ncomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the system, as a rectangular 2D array with dimensions *(n,k)*, where *n* is the number of compartments and *k* is the number of time points in *J*.</span>
<span class="sd">        T (array_like): n-element array with mean transit times of each compartment.</span>
<span class="sd">        E (array_like): dimensionless and square *n x n* matrix. An off-diagonal element *E[j,i]* is the extraction fraction from compartment *i* to compartment *j*. A diagonal element *E[i,i]* is the extraction fraction from compartment *i* to the outside. </span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux *J*, in the same units as *T*. If *t* is not provided, the time points are assumed to be uniformly spaced with spacing *dt*. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as *T*. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): A string specifying the numerical method for solving the system. Two options are available: with `solver = &#39;diag&#39;` the system is solved by diagonalising the system matrix, with `solver = &#39;prop&#39;` the system is solved by forward propagation. The default is `&#39;diag&#39;`.</span>
<span class="sd">        dt_prop (float, optional): internal time resolution for the forward propagation when `solver = &#39;prop&#39;`. This must be in the same units as *T*. If *dt_prop* is not provided, it defaults to the sampling interval, or the smallest time step needed for stable results (whichever is smaller). This argument is ignored when `solver = &#39;diag&#39;`. Defaults to None. </span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Outflux out of each compartment, and at each time point, as a 3D array with dimensions *(n,n,k)*, where *n* is the number of compartments and *k* is the number of time points in *J*. Encoding of the first two indices is the same as for *E*: *J[j,i,:]* is the flux from compartment *i* to *j*, and *J[i,i,:]* is the flux from *i* directly to the outside.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `res_ncomp`, `prop_ncomp`, `conc_ncomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>

<span class="sd">        Consider a measurement with 10 time points from 0 to 20s, and a 2-compartment system with a constant influx in each compartment. The influx in compartment 1 is twice a large than in compartment 0:</span>

<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 20, 10)</span>
<span class="sd">        &gt;&gt;&gt; J = np.zeros((2, t.size))</span>
<span class="sd">        &gt;&gt;&gt; J[0,:] = 1</span>
<span class="sd">        &gt;&gt;&gt; J[1,:] = 2</span>

<span class="sd">        The transit times are 6s for compartment 0 and 12s for compartment 1. </span>

<span class="sd">        &gt;&gt;&gt; T = [6,12]</span>

<span class="sd">        The extraction fraction from compartment 0 to compartment 1 is 0.3 and the extraction fraction from 1 to 0 is 0.8. These are the off-diagonal elements of *E*. No indicator is trapped or created inside the system so the extraction fractions for each compartment must add up to 1. The extraction fractions to the outside are therefore 0.7 and 0.2 for compartment 0 and 1, respectively. These are the diagonal elements of *E*:</span>

<span class="sd">        &gt;&gt;&gt; E = [</span>
<span class="sd">        ...  [0.7, 0.8],</span>
<span class="sd">        ...  [0.3, 0.2]]</span>

<span class="sd">        Calculate the outflux out of both compartments:</span>

<span class="sd">        &gt;&gt;&gt; J = dc.flux_ncomp(J, T, E, t)</span>

<span class="sd">        The indicator flux out of compartment 0 to the outside is:</span>

<span class="sd">        &gt;&gt;&gt; J[0,0,:]</span>
<span class="sd">        array([0.        , 0.25925926, 0.49931413, 0.71731951, 0.91301198,</span>
<span class="sd">        1.0874238 , 1.24217685, 1.37910125, 1.50003511, 1.60672472])</span>

<span class="sd">        The indicator flux from compartment 1 to 0 is:</span>

<span class="sd">        &gt;&gt;&gt; J[1,0,:]</span>
<span class="sd">        array([0.        , 0.11111111, 0.21399177, 0.30742265, 0.39129085,</span>
<span class="sd">        0.46603877, 0.53236151, 0.59104339, 0.64287219, 0.68859631])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">conc_ncomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">dt_prop</span><span class="o">=</span><span class="n">dt_prop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_J_ncomp</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span></div>



<div class="viewcode-block" id="res_ncomp">
<a class="viewcode-back" href="../../api/dcmri.res_ncomp.html#dcmri.res_ncomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">res_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue function of an n-compartment system.</span>

<span class="sd">    See section :ref:`define-ncomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (array_like): n-element array with mean transit times of each compartment.</span>
<span class="sd">        E (array_like): dimensionless and square *n x n* matrix. An off-diagonal element *E[j,i]* is the extraction fraction from compartment *i* to compartment *j*. A diagonal element *E[i,i]* is the extraction fraction from compartment *i* to the outside. </span>
<span class="sd">        t (array_like): the time points of the indicator flux *J*, in the same units as *T*. If *t* is not provided, the time points are assumed to be uniformly spaced with spacing *dt*. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Residue in each compartment, and at each time point, as a 3D array with dimensions *(n,n,k)*, where *n* is the number of compartments and *k* is the number of time points in *t*. Encoding of the first two indices is as follows: *R[j,i,:]* is the residue in compartment *i* from an impulse injected into compartment *J*.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `flux_ncomp`, `prop_ncomp`, `conc_ncomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>

<span class="sd">        Consider a measurement with 10 time points from 0 to 20s, and a 2-compartment system defined by *T* and *E* as follows:</span>

<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 20, 10)</span>
<span class="sd">        &gt;&gt;&gt; T = [20,2]</span>
<span class="sd">        &gt;&gt;&gt; E = [[0.7, 0.9], [0.3, 0.1]]</span>

<span class="sd">        Calculate the residue in both compartments:</span>

<span class="sd">        &gt;&gt;&gt; R = dc.res_ncomp(T, E, t)</span>

<span class="sd">        Given an impulse in compartment 1 at time *t=0*, the residue in compartment 1 is strictly decreasing: </span>

<span class="sd">        &gt;&gt;&gt; R[1,1,:]</span>
<span class="sd">        array([1.        , 0.337098  , 0.12441734, 0.05534255, 0.03213718,</span>
<span class="sd">        0.02364203, 0.01991879, 0.01779349, 0.01624864, 0.01495455])</span>

<span class="sd">        Given an impulse in compartment 1 at time *t=0*, the residue in compartment 0 is zero initially and peaks at a later time:</span>

<span class="sd">        &gt;&gt;&gt; R[1,0,:]</span>
<span class="sd">        array([0.        , 0.01895809, 0.02356375, 0.02370372, 0.02252098,</span>
<span class="sd">        0.02100968, 0.01947964, 0.01802307, 0.01666336, 0.0154024 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_res_2comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="c1"># Calculate system matrix, eigenvalues and eigenvectors</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">_K_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">Qi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="c1"># Initialize concentration-time array</span>
    <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">Ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Loop over the inlets</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="c1"># Loop over the eigenvalues</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
            <span class="c1"># Calculate elements of diagonal matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="c1"># Right-multiply with inverse eigenvector matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">Qi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="c1"># Left-multiply with eigenvector matrix</span>
        <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Ei</span><span class="p">)</span>
    <span class="c1"># Absolute because K can be complex</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></div>



<div class="viewcode-block" id="prop_ncomp">
<a class="viewcode-back" href="../../api/dcmri.prop_ncomp.html#dcmri.prop_ncomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prop_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagator of an n-compartment system.</span>

<span class="sd">    See section :ref:`define-ncomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        T (array_like): n-element array with mean transit times of each compartment.</span>
<span class="sd">        E (array_like): dimensionless and square *n x n* matrix. An off-diagonal element *E[j,i]* is the extraction fraction from compartment *i* to compartment *j*. A diagonal element *E[i,i]* is the extraction fraction from compartment *i* to the outside. </span>
<span class="sd">        t (array_like): the time points of the indicator flux *J*, in the same units as *T*. If *t* is not provided, the time points are assumed to be uniformly spaced with spacing *dt*. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Propagator for each arrow as a 4D array with dimensions *(n,n,n,k)*, where *n* is the number of compartments and *k* is the number of time points in *t*. Encoding of the first indices is as follows: *H[i,k,j,:]* is the propagator from the inlet at compartment *i* to the outlet from *j* to *k*. The diagonal element *H[i,j,j,:]* is the propagator from the inlet at *i* to the outlet of *j* to the environment.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `flux_ncomp`, `res_ncomp`, `conc_ncomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>

<span class="sd">        Consider a measurement with 10 time points from 0 to 20s, and a 2-compartment system defined by *T* and *E* as follows:</span>

<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 20, 10)</span>
<span class="sd">        &gt;&gt;&gt; T = [20,2]</span>
<span class="sd">        &gt;&gt;&gt; E = [[0.7, 0.9], [0.3, 0.1]]</span>

<span class="sd">        Calculate the propagator for the system:</span>

<span class="sd">        &gt;&gt;&gt; H = dc.prop_ncomp(T, E, t)</span>

<span class="sd">        The propagator from the inlet at 1 (first index = 1) to the outlet of compartment 0 is: </span>

<span class="sd">        &gt;&gt;&gt; H[1,0,0,:]</span>
<span class="sd">        array([0.        , 0.019906  , 0.02474194, 0.0248889 , 0.02364703,</span>
<span class="sd">        0.02206017, 0.02045362, 0.01892422, 0.01749653, 0.01617252])</span>

<span class="sd">        The propagator from the inlet at 1 (first index = 1) to the outlet from 0 to 1 is:</span>

<span class="sd">        &gt;&gt;&gt; H[1,1,0,:]</span>
<span class="sd">        array([0.        , 0.00853114, 0.01060369, 0.01066667, 0.01013444,</span>
<span class="sd">        0.00945436, 0.00876584, 0.00811038, 0.00749851, 0.00693108])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">res_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_J_ncomp</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>



<span class="c1"># 2 compartments (analytical)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_K_2comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">_K_ncomp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">K</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">K</span>
    <span class="c1"># Calculate the eigenvalues Ke</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">Ke</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">),</span>
          <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">)]</span>
    <span class="c1"># Build the matrix of eigenvectors (one per column)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Ke</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Ke</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="p">])</span>
    <span class="c1"># Build the inverse of the eigenvector matrix</span>
    <span class="n">Qi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Ke</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Ke</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">])</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Ke</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Ke</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">Qi</span> <span class="o">/=</span> <span class="n">N</span>
    <span class="k">return</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Ke</span><span class="p">,</span> <span class="n">Qi</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_conc_2comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Check input parameters</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;T must be strictly positive.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="c1"># Build the system matrix K</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Qi</span> <span class="o">=</span> <span class="n">_K_2comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="c1"># Initialize concentration-time array</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
    <span class="n">Ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
    <span class="c1"># Loop over the inlets</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># Loop over th eigenvalues</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># Calculate elements of diagonal matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="o">/</span><span class="n">K</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
            <span class="c1"># Right-multiply with inverse eigenvector matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">Qi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="c1"># Left-multiply with eigenvector matrix</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Ei</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_res_2comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># Calculate system matrix, eigenvalues and eigenvectors</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Qi</span> <span class="o">=</span> <span class="n">_K_2comp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="c1"># Initialize concentration-time array</span>
    <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
    <span class="n">Ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
    <span class="c1"># Loop over the inlets</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="c1"># Loop over the eigenvalues</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
            <span class="c1"># Calculate elements of diagonal matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="c1"># Right-multiply with inverse eigenvector matrix</span>
            <span class="n">Ei</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">Qi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="c1"># Left-multiply with eigenvector matrix</span>
        <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Ei</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span>


<span class="c1"># Non-stationary compartment</span>


<div class="viewcode-block" id="conc_nscomp">
<a class="viewcode-back" href="../../api/dcmri.conc_nscomp.html#dcmri.conc_nscomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_nscomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a non-stationary compartment.</span>

<span class="sd">    See section :ref:`define-nscomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment.</span>
<span class="sd">        T (array_like): array with the mean transit time as a function of time, with the same length as *J*. Only finite and strictly positive values are allowed.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if one of the parameters is out of bounds.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `flux_nscomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; T = [1,2,3,4,5]</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_nscomp(J, T, t)</span>
<span class="sd">        array([ 0.        ,  3.09885687,  7.96130923, 11.53123615, 10.28639254])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;T must be an array of the same length as J.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;T and J must have the same length.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;T must be strictly positive.&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Dk</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">Tk</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">Fk</span> <span class="o">=</span> <span class="n">Dk</span><span class="o">/</span><span class="n">Tk</span>
        <span class="k">if</span> <span class="n">Fk</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Jk</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">Dk</span><span class="o">*</span><span class="n">Jk</span> <span class="o">-</span> <span class="n">Fk</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Dk</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">])))</span>
            <span class="n">STk</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="n">Dk</span>
            <span class="n">SJk</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="n">Dk</span>
            <span class="n">Jk</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">Tk</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">Ck</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">Dk</span><span class="o">/</span><span class="n">nk</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="n">Jk_next</span> <span class="o">=</span> <span class="n">Jk</span> <span class="o">+</span> <span class="n">dk</span><span class="o">*</span><span class="n">SJk</span>
                <span class="n">Tk_next</span> <span class="o">=</span> <span class="n">Tk</span> <span class="o">+</span> <span class="n">dk</span><span class="o">*</span><span class="n">STk</span>
                <span class="n">Jk_curr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jk</span><span class="o">+</span><span class="n">Jk_next</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">Tk_curr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tk</span><span class="o">+</span><span class="n">Tk_next</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">Ck</span> <span class="o">=</span> <span class="n">Ck</span> <span class="o">+</span> <span class="n">dk</span><span class="o">*</span><span class="n">Jk_curr</span> <span class="o">-</span> <span class="n">dk</span><span class="o">*</span><span class="n">Ck</span><span class="o">/</span><span class="n">Tk_curr</span>
                <span class="n">Jk</span> <span class="o">=</span> <span class="n">Jk_next</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">Tk_next</span>
            <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ck</span>
    <span class="k">return</span> <span class="n">C</span></div>



<div class="viewcode-block" id="flux_nscomp">
<a class="viewcode-back" href="../../api/dcmri.flux_nscomp.html#dcmri.flux_nscomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_nscomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a non-stationary compartment.</span>

<span class="sd">    See section :ref:`define-nscomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment.</span>
<span class="sd">        T (array_like): array with the mean transit time as a function of time, with the same length as *J*. Only finite and strictly positive values are allowed.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in the same units as T. If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points, in the same units as T. This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: outflux as a 1D array.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `conc_nscomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; T = [1,2,3,4,5]</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_nscomp(J, T, t)</span>
<span class="sd">        array([0.        , 1.54942844, 2.65376974, 2.88280904, 2.05727851])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">conc_nscomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">/</span><span class="n">T</span></div>


<span class="c1"># TODO: Defaults for solver to None - everywhere</span>




<span class="c1"># Michaelis-Menten compartment</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_mmcomp_solve</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># Schnell-Mendoza</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Dk</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">Jk</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">Km</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">Vmax</span><span class="o">*</span><span class="n">Dk</span><span class="p">)</span><span class="o">/</span><span class="n">Km</span><span class="p">)</span>
        <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jk</span><span class="o">*</span><span class="n">Dk</span> <span class="o">+</span> <span class="n">Km</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambertw</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_mmcomp_prop</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Dk</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">SJk</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="n">Dk</span>
        <span class="n">Jk</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">Ck</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">Tk</span> <span class="o">=</span> <span class="p">(</span><span class="n">Km</span><span class="o">+</span><span class="n">Ck</span><span class="p">)</span><span class="o">/</span><span class="n">Vmax</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Dk</span><span class="o">/</span><span class="n">Tk</span><span class="p">))</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">Dk</span><span class="o">/</span><span class="n">nk</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">Jk_next</span> <span class="o">=</span> <span class="n">Jk</span> <span class="o">+</span> <span class="n">dk</span><span class="o">*</span><span class="n">SJk</span>
            <span class="n">Jk_curr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jk</span><span class="o">+</span><span class="n">Jk_next</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">Ck</span> <span class="o">=</span> <span class="n">Ck</span> <span class="o">+</span> <span class="n">dk</span><span class="o">*</span><span class="n">Jk_curr</span> <span class="o">-</span> <span class="n">dk</span><span class="o">*</span><span class="n">Ck</span><span class="o">*</span><span class="n">Vmax</span><span class="o">/</span><span class="p">(</span><span class="n">Km</span><span class="o">+</span><span class="n">Ck</span><span class="p">)</span>
            <span class="n">Jk</span> <span class="o">=</span> <span class="n">Jk_next</span>
            <span class="n">Ck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="n">Ck</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ck</span>
    <span class="k">return</span> <span class="n">C</span>


<div class="viewcode-block" id="conc_mmcomp">
<a class="viewcode-back" href="../../api/dcmri.conc_mmcomp.html#dcmri.conc_mmcomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_mmcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator concentration inside a Michaelis-Menten compartment.</span>

<span class="sd">    See section :ref:`define-mmcomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment.</span>
<span class="sd">        Vmax (float): Limiting rate in the same units as J. Must be </span>
<span class="sd">          non-negative.</span>
<span class="sd">        Km (float): Michaelis-Menten constant in units of concentration (or </span>
<span class="sd">          flux x time). Must be non-negative.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in </span>
<span class="sd">          the same units as Km/Vmax. If t=None, the time points are assumed </span>
<span class="sd">          to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced </span>
<span class="sd">          time points, in the same units as Km/Vmax. This parameter is ignored </span>
<span class="sd">          if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): choose which solver to use. The options are </span>
<span class="sd">          &#39;SM&#39; for the Schnell and Mendoza solution or &#39;prop&#39; for a numerical </span>
<span class="sd">          solution by forward propagation. Defaults to &#39;SM&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if one of the parameters is out of bounds.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `flux_mmcomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; Vmax, Km = 1, 12</span>
<span class="sd">        &gt;&gt;&gt; dc.conc_mmcomp(J, Vmax, Km, t)</span>
<span class="sd">        array([  0.        ,   7.5       ,  29.26723718,  64.27756059,</span>
<span class="sd">        114.97656637])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Vmax</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Vmax must be non-negative.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Km</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Km must be non-negative.&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;SM&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_mmcomp_solve</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;prop&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_mmcomp_prop</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>



<div class="viewcode-block" id="flux_mmcomp">
<a class="viewcode-back" href="../../api/dcmri.flux_mmcomp.html#dcmri.flux_mmcomp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_mmcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a Michaelis-Menten compartment.</span>

<span class="sd">    See section :ref:`define-mmcomp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment.</span>
<span class="sd">        Vmax (float): Limiting rate in the same units as J. Must be </span>
<span class="sd">          non-negative.</span>
<span class="sd">        Km (float): Michaelis-Menten constant in units of concentration (or </span>
<span class="sd">          flux x time). Must be non-negative.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J, in </span>
<span class="sd">          the same units as Km/Vmax. If t=None, the time points are assumed to </span>
<span class="sd">          be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced </span>
<span class="sd">          time points, in the same units as Km/Vmax. This parameter is ignored </span>
<span class="sd">          if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): choose which solver to use. The options are </span>
<span class="sd">          &#39;SM&#39; for the Schnell and Mendoza solution, </span>
<span class="sd">          or &#39;prop&#39; for a numerical solution by forward propagation. </span>
<span class="sd">          Defaults to &#39;SM&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Outflux as a 1D array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if one of the parameters is out of bounds.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `conc_mmcomp`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import dcmri as dc</span>
<span class="sd">        &gt;&gt;&gt; t = [0,5,15,30,60]</span>
<span class="sd">        &gt;&gt;&gt; J = [1,2,3,3,2]</span>
<span class="sd">        &gt;&gt;&gt; Vmax, Km = 1, 12</span>
<span class="sd">        &gt;&gt;&gt; dc.flux_mmcomp(J, Vmax, Km, t)</span>
<span class="sd">        array([0.        , 0.38461538, 0.70921242, 0.84267981, 0.90549437])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">conc_mmcomp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">*</span><span class="n">Vmax</span><span class="o">/</span><span class="p">(</span><span class="n">Km</span><span class="o">+</span><span class="n">C</span><span class="p">)</span></div>



<span class="c1"># Two-compartment exchange</span>

<div class="viewcode-block" id="conc_2cxm">
<a class="viewcode-back" href="../../api/dcmri.conc_2cxm.html#dcmri.conc_2cxm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">conc_2cxm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a 2-compartment exchange model.</span>

<span class="sd">    See section :ref:`define-2comp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment (mmol/sec).</span>
<span class="sd">        T (array-like): 2-element array with mean transit times of plasma and extravascular compartment. Mean transit times can take any value, including 0 and inf. Negative values are unphysical but will only trigger an error if no solution exists.</span>
<span class="sd">        E (float): Extraction fraction out of the plasma compartment. E is a value between 0 and 1, and boundary values E=0 and E=1 are correctly handled. Values outside that range are unphysical but will only trigger an error if no solution exists.        </span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J (sec). If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points (sec). This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if no real solution exists because of unphysical parameter values (usually E&lt;0).</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Concentration in each compartment, and at each time point, as a 2D array with dimensions *(2,k)*, where 2 is the number of compartments and *k* is the number of time points in *J*. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># T = [ Tp, Te]</span>

    <span class="c1"># Definition</span>
    <span class="c1"># ----------</span>
    <span class="c1"># vp cp&#39; = Fpca - Fpcp + PSci - PScp</span>
    <span class="c1"># vi ci&#39; = PScp - PSci</span>
    <span class="c1">#</span>
    <span class="c1"># vp, vi, Fp, PS</span>


    <span class="c1"># C-form</span>
    <span class="c1"># ------</span>
    <span class="c1"># Cp&#39; = Fpca - (Fp/vp)Cp + (PS/vi)Ci - (PS/vp)Cp</span>
    <span class="c1"># Ci&#39; = (PS/vp)Cp - (PS/vi)Ci</span>
    <span class="c1">#</span>
    <span class="c1"># Cp&#39; = Ja - Cp/Tp + Ci/Ti</span>
    <span class="c1"># Ci&#39; = Cp*E/Tp - Ci/Ti</span>
    <span class="c1">#</span>
    <span class="c1"># E, Tp, Ti</span>
    <span class="c1">#</span>
    <span class="c1"># Cp        ca       1/Tp  -1/Ti      Cp</span>
    <span class="c1">#     = Fp      - </span>
    <span class="c1"># Ci         0      -E/Tp   1/Ti      Ci</span>


    <span class="c1"># c-form</span>
    <span class="c1"># ------</span>
    <span class="c1"># cp&#39; = (Fp/vp)ca - (Fp/vp)cp + (PS/vp)ci - (PS/vp)cp</span>
    <span class="c1"># ci&#39; = (PS/vi)cp - (PS/vi)ci   </span>
    <span class="c1"># </span>
    <span class="c1"># cp&#39; = Ja - cp/Tp + ci*E/Tp </span>
    <span class="c1"># ci&#39; = cp/Ti - ci/Ti </span>
    <span class="c1">#</span>
    <span class="c1"># E, Tp, Ti</span>

    <span class="c1">#</span>
    <span class="c1"># cp           ca       1/Tp  -E/Tp      cp</span>
    <span class="c1">#     = Fp/vp      - </span>
    <span class="c1"># ci            0      -1/Ti   1/Ti      ci</span>

    <span class="k">if</span> <span class="n">E</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Cp</span> <span class="o">=</span> <span class="n">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">Ce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">E</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># D</span>
        <span class="c1"># = sqrt( (Kp-Ke)**2 + 4 E Kp Ke  )</span>
        <span class="c1"># = sqrt( (Kp+Ke)**2 -4KeKp + 4 E Kp Ke  )</span>
        <span class="c1"># = sqrt( (Kp+Ke)**2 - 4(1-E)KeKp)</span>
        <span class="c1"># D(x) = sqrt( (Kp+Ke)**2 - 4 x KeKp)</span>
        <span class="c1"># D(0) = Kp+Ke</span>
        <span class="c1"># D&#39;(x) = 0.5 ( (Kp+Ke)**2 - 4 x KeKp)**(-0.5) (-4 KeKp)</span>
        <span class="c1"># D&#39;(0) = -2 KeKp/(Kp+Ke)</span>
        <span class="c1"># D = Kp+Ke -2 (1-E) KeKp/(Kp+Ke)</span>

        <span class="c1"># KT = Kp + Ke</span>
        <span class="c1"># Kpos = Kp + Ke</span>
        <span class="c1"># Kneg = (1-E) KeKp/(Kp+Ke)</span>

        <span class="c1"># Jpos</span>
        <span class="c1"># = utils.expconv(J, 1/Kpos, t=t, dt=dt)</span>
        <span class="c1"># Jneg</span>
        <span class="c1"># = Kneg exp(-tKneg) * J</span>

        <span class="c1"># Eneg</span>
        <span class="c1"># = (Kp+Ke - (1-E)Kp) / (Kp+Ke - (1-E) KeKp/(Kp+Ke))</span>

        <span class="c1"># 1 - Eneg</span>
        <span class="c1"># = [Kp+Ke - (1-E) KeKp/(Kp+Ke) - (Kp+Ke - (1-E)Kp)] / (Kp+Ke - (1-E) KeKp/(Kp+Ke))</span>
        <span class="c1"># = [(1-E)Kp - (1-E) KeKp/(Kp+Ke)] / (Kp+Ke - (1-E) KeKp/(Kp+Ke))</span>
        <span class="c1"># = (1-E) [Kp - KeKp/(Kp+Ke)] / (Kp+Ke - (1-E) KeKp/(Kp+Ke))</span>

        <span class="c1"># 1- Eneg = Epos</span>
        <span class="c1"># approx  [Kp - KeKp/(Kp+Ke)] (1-E) / (Kp+Ke)</span>
        <span class="c1"># (1-E) [Kp - KeKp/(Kp+Ke)] / (Kp+Ke)</span>
        <span class="c1"># (1-E) Rpos</span>

        <span class="c1"># Cp</span>
        <span class="c1"># = [ Epos*Jpos + Eneg*Jneg ] (1/Kp) / (1-E)</span>
        <span class="c1"># = [ Rpos*Jpos + (KeKp/(Kp+Ke)) exp(-tKneg) * J  ] (1/Kp)</span>
        <span class="c1"># = [ Rpos*Jpos + (KeKp/(Kp+Ke)) * J  ] (1/Kp)</span>
        <span class="c1"># = [ Jpos [Kp - KeKp/(Kp+Ke)] / (Kp+Ke) + (KeKp/(Kp+Ke)) * J  ] (1/Kp)</span>
        <span class="c1"># = [ Jpos [Kp - KeKp/(Kp+Ke)]  + KeKp * J  ] (1/Kp)  / (Kp+Ke)</span>
        <span class="c1"># Ce</span>
        <span class="c1"># = [(Kneg exp(-tKneg) * J*Kpos - Jpos*Kneg) / (Kpos - Kneg)] (1/Ke) E / (1-E)</span>
        <span class="c1"># = [Kpos exp(-tKneg) * J - Jpos) / (Kpos - Kneg)] Kneg (1/Ke) E / (1-E)</span>
        <span class="c1"># = [Kpos exp(-tKneg) * J - Jpos) / (Kpos - Kneg)] KeKp/(Kp+Ke) (1/Ke)</span>
        <span class="c1"># = [(Ke + Kp) exp(-tKneg) * J - Jpos) / (Ke + Kp)] KeKp/(Kp+Ke) (1/Ke)</span>
        <span class="c1"># = [(Ke + Kp) * J - Jpos) / (Ke + Kp)] KeKp/(Kp+Ke) (1/Ke)</span>

        <span class="c1"># Kp, Ke = 1/T[0], 1/T[1]</span>
        <span class="c1"># Kpos = Kp + Ke</span>
        <span class="c1"># Jpos = utils.expconv(J, 1/Kpos, t=t, dt=dt)</span>

        <span class="c1"># Jint = conc_trap(J, t=t, dt=dt)</span>

        <span class="c1"># K = Ke*Kp/(Kp+Ke)</span>

        <span class="c1"># Cp = ( Jpos*(Kp - K)  + Ke*Kp * Jint  ) * (1/Kp)  / (Kp+Ke)</span>
        <span class="c1"># Ce = ( (Jint - Jpos/(Ke + Kp))  ) * (1/Ke) * K</span>

        <span class="c1"># Cp = ( Jpos*(Kp - Ke*Kp/(Kp+Ke))  + Ke*Kp * Jint  ) * (1/Kp)  / (Kp+Ke)</span>
        <span class="c1"># Ce = ( (Jint - Jpos/(Ke + Kp))  ) * (1/Ke) * Ke*Kp/(Kp+Ke)</span>

        <span class="c1"># Cp = ( Jpos*(1/Ke - 1/(Kp+Ke))  +  Jint  ) * Ke/(Kp+Ke)</span>
        <span class="c1"># Ce = ( (Jint - Jpos/(Ke + Kp))  ) * Kp/(Kp+Ke)</span>

        <span class="c1"># Solution In Kp-representation</span>
        <span class="c1"># Cp = ( Jpos* Kp/(Kp+Ke)  +  Ke*Jint  ) /(Kp+Ke)</span>
        <span class="c1"># Ce = ( (Jint - Jpos/(Ke + Kp))  ) *Kp/(Kp+Ke)</span>

        <span class="c1"># Solution In Tp-representation</span>
        <span class="c1"># Tp, Te = T[0], T[1]</span>

        <span class="c1"># Cp = ( Jpos* Te/(Tp+Te)  +  Jint /Te ) *Tp*Te/(Tp+Te)</span>
        <span class="c1"># Ce = ( (Jint - Jpos*Tp*Te/(Tp + Te))  ) *Te/(Tp+Te)</span>

        <span class="n">Jint</span> <span class="o">=</span> <span class="n">conc_trap</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
            <span class="n">Ce</span> <span class="o">=</span> <span class="n">Jint</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Cp</span> <span class="o">=</span> <span class="n">Jint</span>
            <span class="n">Ce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">Cp</span> <span class="o">=</span> <span class="n">Jint</span>
            <span class="n">Ce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># T[0] is not inf - covered above</span>
            <span class="n">Jpos</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">Cp</span> <span class="o">=</span> <span class="n">Jpos</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Ce</span> <span class="o">=</span> <span class="n">Jint</span> <span class="o">-</span> <span class="n">Jpos</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

        <span class="n">Kpos</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Jpos</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Kpos</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Cp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jpos</span> <span class="o">*</span> <span class="n">X</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Jint</span> <span class="o">/</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">X</span>
        <span class="n">Ce</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jint</span> <span class="o">-</span> <span class="n">Jpos</span><span class="o">*</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check:</span>
        <span class="c1"># Cp + Ce</span>
        <span class="c1"># Jint (X/T[1] + X/T[0]) + Jpos(X*X/T[0] - X*X/T[0])</span>
        <span class="c1"># = Jint</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># D = sqrt( (1/TP-1/TE)**2 + 4 * E * (1/TP) * (1/TE)  )</span>
        <span class="c1"># D = (1/TP) * sqrt( (1-TP/TE)**2 + 4 * E * TP/TE)</span>
        <span class="c1"># KT = 1/TP + 1/TE</span>
        <span class="c1"># KT = (1/TP) (1 + TP/TE)</span>
        <span class="c1"># Kpos = 0.5/TP * [ 1 + TP/TE + sqrt( (1-TP/TE)**2 + 4 * E * TP/TE) ]</span>
        <span class="c1"># Kneg = 0.5/TP * [ 1 + TP/TE - sqrt( (1-TP/TE)**2 + 4 * E * TP/TE) ]</span>
        <span class="c1"># First order term in Kneg dominates so need power expansion:</span>
        <span class="c1"># f(x) = sqrt( (1-x)**2 + 4E*x )</span>
        <span class="c1"># f(0) = 1</span>
        <span class="c1"># f&#39;(x) = 1/2 * ((1-x)**2 + 4E*x)**(-1/2) * (-2*(1-x)+4E)</span>
        <span class="c1"># f&#39;(0) = 1/2 * (-2+4E) = -1+2E</span>
        <span class="c1"># f(x) = 1 + (-1+2E)*x</span>
        <span class="c1"># TP-&gt;0:</span>
        <span class="c1"># Kpos = 0.5/TP * 2</span>
        <span class="c1"># Kpos = 1/TP</span>
        <span class="c1"># Kneg = 0.5/TP * [ TP/TE - (-1+2E) TP/TE]</span>
        <span class="c1"># Kneg = 0.5 * [1 - (-1+2E)] / TE</span>
        <span class="c1"># Kneg = (1-E)/TE</span>
        <span class="c1"># Then:</span>
        <span class="c1"># KB = (1-E)/TP</span>
        <span class="c1"># Eneg = (1/TP - (1-E)/TP) / (1/TP - (1-E)/TE)</span>
        <span class="c1"># Eneg = E / (1 - (1-E) TP/TE)</span>
        <span class="c1"># Eneg -&gt; E</span>

        <span class="c1"># Jpos = J</span>
        <span class="n">Jneg</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># Je = (Jneg/TP - Jpos*(1-E)/TE) / (1/TP - (1-E)/TE)</span>
        <span class="c1"># Je = (Jneg - TP*Jpos*(1-E)/TE) / (1 - TP(1-E)/TE)</span>
        <span class="c1"># Je = Jneg</span>

        <span class="c1"># Jp = (1-E)*Jpos + E*Jneg</span>
        <span class="c1"># Je = Jneg</span>

        <span class="c1"># Cp = 0*Jp</span>
        <span class="n">Cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
        <span class="n">Ce</span> <span class="o">=</span> <span class="n">Jneg</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># D symmetric in TP and TE, so power expansion in TE is:</span>
        <span class="c1"># Kpos = 1/TE</span>
        <span class="c1"># Kneg = (1-E)/TP</span>

        <span class="c1"># Jpos = J</span>
        <span class="n">Jneg</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># KB = (1-E)/TP</span>
        <span class="c1"># Eneg = (1/TE - (1-E)/TP) / (1/TE - (1-E)/TP) = 1</span>

        <span class="n">Jp</span> <span class="o">=</span> <span class="n">Jneg</span>
        <span class="c1"># Je</span>
        <span class="c1"># = (Jneg/TE - Jpos*(1-E)/TP) / (1/TE - (1-E)/TP)</span>
        <span class="c1"># = Jneg</span>
        <span class="c1"># Je = Jneg</span>

        <span class="n">Cp</span> <span class="o">=</span> <span class="n">Jp</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span>
        <span class="c1"># Ce = Je*0</span>
        <span class="n">Ce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Cp</span> <span class="o">=</span> <span class="n">conc_trap</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">Ce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">Cp</span> <span class="o">=</span> <span class="n">conc_comp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">Jp</span> <span class="o">=</span> <span class="n">Cp</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Ce</span> <span class="o">=</span> <span class="n">conc_trap</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">Jp</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span>

    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">E</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="p">])</span>

    <span class="n">Dsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Dsq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No real solution to the 2CXM exists because of unphysical parameter values.&#39;</span>
        <span class="k">if</span> <span class="n">E</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">-&gt; The extraction fraction is negative (E = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;).&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Dsq</span><span class="p">)</span>

    <span class="n">KT</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">Kpos</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">KT</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span>
    <span class="n">Kneg</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">KT</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span>

    <span class="n">Jpos</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Kpos</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Jneg</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Kneg</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">KB</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">Eneg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Kpos</span> <span class="o">-</span> <span class="n">KB</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Kpos</span> <span class="o">-</span> <span class="n">Kneg</span><span class="p">)</span>

    <span class="n">Jp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Eneg</span><span class="p">)</span><span class="o">*</span><span class="n">Jpos</span> <span class="o">+</span> <span class="n">Eneg</span><span class="o">*</span><span class="n">Jneg</span>
    <span class="n">Je</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jneg</span><span class="o">*</span><span class="n">Kpos</span> <span class="o">-</span> <span class="n">Jpos</span><span class="o">*</span><span class="n">Kneg</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Kpos</span> <span class="o">-</span> <span class="n">Kneg</span><span class="p">)</span>

    <span class="c1"># Jp = Fp*cp, Cp = vp*cp -&gt; Jp/Cp = Fp/vp = (1-E)/TP -&gt; Cp = Jp*TP/(1-E)</span>
    <span class="c1"># Je = Fp*ce, Ce = ve*ce -&gt; Je/Ce = Fp/ve = (1-E)/E * 1/TE -&gt; Ce = Je*TE * E/(1-E)</span>

    <span class="n">Cp</span> <span class="o">=</span> <span class="n">Jp</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span>
    <span class="n">Ce</span> <span class="o">=</span> <span class="n">Je</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Cp</span><span class="p">,</span> <span class="n">Ce</span><span class="p">))</span></div>



<div class="viewcode-block" id="flux_2cxm">
<a class="viewcode-back" href="../../api/dcmri.flux_2cxm.html#dcmri.flux_2cxm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flux_2cxm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicator flux out of a 2-compartment exchange model.</span>

<span class="sd">    See section :ref:`define-2comp` for more detail.</span>

<span class="sd">    Args:</span>
<span class="sd">        J (array_like): the indicator flux entering the compartment (mmol/sec).</span>
<span class="sd">        T (array-like): 2-element array with mean transit times of plasma and extravascular compartment. Mean transit times can take any value, including 0 and inf. Negative values are unphysical but will only trigger an error if no solution exists.</span>
<span class="sd">        E (float): Extraction fraction out of the plasma compartment. E is a value between 0 and 1, and boundary values E=0 and E=1 are correctly handled. Values outside that range are unphysical but will only trigger an error if no solution exists.</span>
<span class="sd">        t (array_like, optional): the time points of the indicator flux J (sec). If t=None, the time points are assumed to be uniformly spaced with spacing dt. Defaults to None.</span>
<span class="sd">        dt (float, optional): spacing between time points for uniformly spaced time points (sec). This parameter is ignored if t is explicity provided. Defaults to 1.0.</span>
<span class="sd">        solver (str, optional): solver for the system, either &#39;conv&#39; for explicit convolution with a discrete impulse response (slow) or &#39;interp&#39; for interpolation (fast). Defaults to &#39;interp&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Outflux in mmol/sec </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># T = [ Tp, Te]</span>

    <span class="c1"># Jp = Fp*cp, Cp = vp*cp -&gt; Jp/Cp = Fp/vp = (1-E)/TP -&gt; Cp = Jp*TP/(1-E)</span>
    <span class="c1"># Jp = Cp*(1-E)/Tp</span>

    <span class="k">if</span> <span class="n">E</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># D = sqrt( (1/TP-1/TE)**2 + 4 * E * (1/TP) * (1/TE)  )</span>
        <span class="c1"># D = (1/TP) * sqrt( (1-TP/TE)**2 + 4 * E * TP/TE)</span>
        <span class="c1"># KT = 1/TP + 1/TE</span>
        <span class="c1"># KT = (1/TP) (1 + TP/TE)</span>
        <span class="c1"># Kpos = 0.5/TP * [ 1 + TP/TE + sqrt( (1-TP/TE)**2 + 4 * E * TP/TE) ]</span>
        <span class="c1"># Kneg = 0.5/TP * [ 1 + TP/TE - sqrt( (1-TP/TE)**2 + 4 * E * TP/TE) ]</span>
        <span class="c1"># First order term in Kneg dominates so need power expansion:</span>
        <span class="c1"># f(x) = sqrt( (1-x)**2 + 4E*x )</span>
        <span class="c1"># f(0) = 1</span>
        <span class="c1"># f&#39;(x) = 1/2 * ((1-x)**2 + 4E*x)**(-1/2) * (-2*(1-x)+4E)</span>
        <span class="c1"># f&#39;(0) = 1/2 * (-2+4E) = -1+2E</span>
        <span class="c1"># f(x) = 1 + (-1+2E)*x</span>
        <span class="c1"># TP-&gt;0:</span>
        <span class="c1"># Kpos = 0.5/TP * 2</span>
        <span class="c1"># Kpos = 1/TP</span>
        <span class="c1"># Kneg = 0.5/TP * [ TP/TE - (-1+2E) TP/TE]</span>
        <span class="c1"># Kneg = 0.5 * [1 - (-1+2E)] / TE</span>
        <span class="c1"># Kneg = (1-E)/TE</span>
        <span class="c1"># Then:</span>
        <span class="c1"># KB = (1-E)/TP</span>
        <span class="c1"># Eneg = (1/TP - (1-E)/TP) / (1/TP - (1-E)/TE)</span>
        <span class="c1"># Eneg = E / (1 - (1-E) TP/TE)</span>
        <span class="c1"># Eneg -&gt; E</span>
        <span class="c1"># Jpos = J</span>
        <span class="c1"># Jneg = utils.expconv(J, T[1]/(1-E), t=t, dt=dt)</span>

        <span class="c1"># Je = (Jneg/TP - Jpos*(1-E)/TE) / (1/TP - (1-E)/TE)</span>
        <span class="c1"># Je = (Jneg - TP*Jpos*(1-E)/TE) / (1 - TP(1-E)/TE)</span>
        <span class="c1"># Je = Jneg</span>

        <span class="c1"># Jp = (1-E)*Jpos + E*Jneg</span>
        <span class="c1"># Je = Jneg</span>

        <span class="c1"># The case E=1 is already handled above</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="n">J</span>

        <span class="n">Jpos</span> <span class="o">=</span> <span class="n">J</span>
        <span class="n">Jneg</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">expconv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="n">Jpos</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">Jneg</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">conc_2cxm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Jp</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">E</span><span class="p">)</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Jp</span></div>


    <span class="c1"># K = np.array([</span>
    <span class="c1">#     [1/T[0], -1/T[1]],</span>
    <span class="c1">#     [-E/T[0], 1/T[1]],</span>
    <span class="c1"># ])</span>

    <span class="c1"># D = np.sqrt((K[0,0]-K[1,1])**2 + 4*K[0,1]*K[1,0])</span>

    <span class="c1"># KT = K[0,0] + K[1,1]</span>
    <span class="c1"># Kpos = 0.5*(KT + D)</span>
    <span class="c1"># Kneg = 0.5*(KT - D)</span>

    <span class="c1"># Jpos = utils.expconv(J, 1/Kpos, t=t, dt=dt)</span>
    <span class="c1"># Jneg = utils.expconv(J, 1/Kneg, t=t, dt=dt)</span>

    <span class="c1"># KB = K[0,0] + K[1,0]</span>
    <span class="c1"># Eneg = (Kpos - KB)/(Kpos - Kneg)</span>

    <span class="c1"># Jp = (1-Eneg)*Jpos + Eneg*Jneg</span>

    <span class="c1"># return Jp</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2024-2025, dcmri contributors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>